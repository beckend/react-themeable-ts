const cn=require("classnames");const assign=require("lodash.assign");const isObject=require("lodash.isobject");const isFunction=require("lodash.isfunction");const size=require("lodash.size");const memoize=require("memoizee");const themeableDefaultMemoizeeOpts={length:false};const truthy=(x)=>x;
exports.themeable=(input)=>{const [theme,classNameDecorator]=Array.isArray(input)&&input.length===2?input:[input,null];if(!isObject(theme))return()=>({});if(isFunction(classNameDecorator)){const classNameDecoratorFn=(...names)=>{if(names.length<1)return{};const styles=names.map((name)=>theme[name]).filter(truthy);if(!styles[0])return{};return{className:classNameDecorator(...styles)}};return memoize(classNameDecoratorFn,themeableDefaultMemoizeeOpts)}const regularFn=(...names)=>{if(names.length<1)return{};
let styleObj={};const classNamesArgsArr=[];names.forEach((value)=>{const themeValue=theme[value];if(Array.isArray(themeValue))classNamesArgsArr.push(themeValue);else if(isObject(themeValue))assign(styleObj,themeValue);else classNamesArgsArr.push(themeValue)});const returned={};if(size(styleObj)>0)returned.style=styleObj;const finalClassname=cn(classNamesArgsArr);if(finalClassname.length>0)returned.className=finalClassname;return returned};return memoize(regularFn,themeableDefaultMemoizeeOpts)};